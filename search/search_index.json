{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what","title":"What?","text":"<p>The SC proposition describes a specification/framework for Minecraft datapacks.</p>"},{"location":"#why","title":"Why?","text":"<p>The cability and community of Minecraft datapack-ing is growing; The standards of datapack inter-operability are lagging far behind. While general \"good practices\" have been developed and shared informally, there is no community consensus or formal documentation of standards.</p> <p>Additionally, datapack manifests (<code>pack.mcmeta</code>) do not support many fundamental features that software package manifests often have, such as dependencies, versioning, metadata, etc. Datapack loading is managed in an ad-hoc manner in-game via the <code>/datapack</code> command; this is very fragile and dependent on the user's knowledge of installed datapacks.</p> <p>More often than not, these issues lead to many datapacks that are silently incompatible with eachother, general avoidance of using datapacks created by other people, and an incentive to make datapacks that \"do it all\" as opposed to modularity.</p>"},{"location":"#how","title":"How?","text":"<p>The SC proposition aims to fix as many of these issues as possible by clearly defining and documenting a set of rules that datapacks must follow.</p> <p>These rules are designed to be:</p> <ul> <li>Implementable with no third party tools. Any developer writing a datapack \"by hand\" should be able to comply with these rules without unreasonable effort.</li> <li>Unobtrusive. Compliance with these rules should not unnecessarily conflict with a developer's desired development practices.</li> <li>Effective. Compliance with these rules should \"just work\".</li> </ul> <p>The SC proposition requires all worlds to have a loader datapack (SlimeCore) installed; issues related to datapack manifests/loading would be impossible to address without this requirement.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>General intermediate-level knowledge of Minecraft commands and datapacks is assumed. Familiarity with SNBT data manipulation via commands, function execution scope/order, and datapack structure are likely required for full understanding of the specification.</p> <p>Basic knowledge of mcdoc (primarily type definitions and dispatching) is required for compliance with rules described in the Mcdoc page.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>It is recommended to read the Terminology page before reading further pages.</p> <p>A first-time reader may have the \"smoothest\" experience reading the pages of the SC proposition as they appear on the left sidebar, and it designed as such; however, this is completely optional.</p>"},{"location":"issues/","title":"Known Issues","text":"<p>In Mcdoc:</p> <p>ISSUE CRITICAL: Currently, mcdoc paths to external packs (as well as any absolute path) rely on knowledge of datapack names; this is problematic conceptually due to it's impurity, and concretely because standard datapack names have multiple formats.</p>"},{"location":"meta_info/","title":"Meta Information","text":""},{"location":"meta_info/#about","title":"About","text":"<p>As the name implies, this is currently a proposition. It is intended to gather community feedback and approval before a finalized version is created. Areas marked by <code>TENTATIVE: &lt;reason&gt;</code> are in particular need of discussion/consensus.</p> <p>Regardless, the described specification is feature-complete and should be able to be implemented fully.</p> <p>For those that desire to give the specification a try: </p> <ul> <li>See Known Issues.</li> <li>If implementing on an existing datapack, please make a backup beforehand.</li> <li>SlimeCore Dev. Tools is an external datapack that provides minimal, useful tools for developing alongside SlimeCore. It is in no way required (and can be re-implemented quite easily), but may reduce friction when trying to get started quickly.</li> <li>Thank you.</li> </ul>"},{"location":"meta_info/#contributingfeedback","title":"Contributing/Feedback","text":"<p>See CONTRIBUTING.md.</p>"},{"location":"meta_info/#author-info","title":"Author Info","text":"<p>The author of the SC proposition is SixSlime.</p> <ul> <li> <p>Discord: sixslime</p> </li> <li> <p>GitHub: sixslimemc (Minecraft org.) / sixslime (user)</p> </li> <li>Email: globbylikesslime@gmail.com</li> </ul>"},{"location":"meta_info/#contributors","title":"Contributors","text":"<p>(None yet.)</p> <p>GitHub Repository</p>"},{"location":"terminology/","title":"Terminology","text":"<p>The following terms are used within these pages to convey specific meanings in most instances; it should be obvious whether or not this meaning is intended through context:</p> <p>Access (verb) - To reference or use in any way. </p> <p>Content (noun) - A general term for anything that can be introduced or changed by a datapack.</p> <p>Define (verb) - To introduce something that does not exist otherwise--usually in the context of structured data or resources.</p> <p>Ephemeral (adjective) - Exists or is useful only within the scope it is defined.</p> <p>External (adjective) - Defined in a namespace other than the pack's primary namespace.</p> <p>Namespace (noun) - A datapack namespace; refers to the name of a 1st level subdirectory of the <code>data</code> directory in a datapack (<code>&lt;datapack name&gt;/data/&lt;namespace&gt;</code>).</p> <p>Owned (adjective) - See Owned Objects.</p> <p>Pack (noun) - Somewhat interchangeable term for \"datapack\"--tends to be used in the context of datapack content, while \"datapack\" tends to be used in the context of datapack files/directories.</p> <p>Pack ID (noun) - See Pack ID. Interchangeable with \"primary namespace\".</p> <p>Persistent (adjective) - Exists for longer than the scope it is defined.</p> <p>Primary Namespace (noun) - See Primary Namespace.</p> <p>Private (adjective) - See Private Content.</p> <p>Public (adjective) - See Private Content.</p> <p>Registry (noun) - A 2nd level subdirectory of the <code>data</code> directory in a datapack (<code>&lt;datapack name&gt;/data/&lt;namespace&gt;/&lt;registry&gt;</code>).</p> <p>Resource (noun) - A file within a registry or registry tag.</p> <p>Scope (noun) - All possible commands that could possibly be executed as a direct result (i.e. would be limited by max_command_sequence_length) of a function's/function tag's execution. </p> <p>The use of uppercase bolded words such as MUST, SHOULD, MAY, etc. are in adherence to RFC 2119.</p> <p>Code-block text surrounded by angle brackets conveys that it should be replaced by what is inside the angle brackets conceptually. For example, in the context of a pack with pack ID <code>foo</code>, <code>&lt;pack ID&gt;</code> means <code>foo</code>.</p>"},{"location":"rules/","title":"Rules","text":"<p>The pages in this section describe subjects not directly related to SlimeCore. </p> <p>While it is still required and assumed that SlimeCore is installed, a majority of rules described in this section can be complied-with independently of SlimeCore's systems.</p>"},{"location":"rules/config/","title":"Pack Config","text":""},{"location":"rules/config/#definition","title":"Definition","text":"<p>A pack's config is all NBT data in the storage location <code>&lt;pack ID&gt;:config</code>.</p> <p>Config is intended to provide a standard method of allowing users to configure pack behavior.</p> <p>Config structure MUST be defined and documented via mcdoc.</p> <p>Packs MUST set default config (for all non-nullable keys) within the scope of their load tag when it is called for the very first time (installation).</p> <p>After a pack's installation, it's config SHOULD NOT be changed anywhere except for in-game.</p> <p>While config MAY be read anytime by any source, it SHOULD be assumed that config is only read directly and cached during loading. (I.e. it should be assumed that changes to config will not affect pack behavior until the next <code>/reload</code>.)</p> <p>Pack authors should take particular note of the NBT struct key naming specification when defining config structure.</p>"},{"location":"rules/function_tags/","title":"Function Tags","text":""},{"location":"rules/function_tags/#definition","title":"Definition","text":"<p>A datapack MUST NOT define any function tags that are not definitions of the following:</p> <ul> <li>Hook</li> <li>Abstract Function</li> <li>Top-Level Function Tag</li> <li>Entrypoint</li> <li>Preload Entrypoint</li> </ul> <p>Function tags (regardless of type) SHOULD NOT be called in-game.</p> <p>Functions included/specified by a function tag are referred to as the tag's subscribers.</p>"},{"location":"rules/function_tags/#hooks","title":"Hooks","text":"<p>A hook is a function tag within the <code>hook</code> directory or any subdirectory therein (<code>#&lt;pack ID&gt;:hook/&lt;path...&gt;/&lt;hook name&gt;</code>).</p> <p>Hooks are public by definition. Any datapack that includes to hook tag MUST set <code>\"replace\": false</code> (or omit <code>replace</code>).</p> <p>While packs can include (declare subscriber(s) for) hooks from outside of their namespace, hooks MUST NOT be called by any namespace other than the one that they are defined in.</p> <p>Hooks MUST be documented via mcdoc.</p>"},{"location":"rules/function_tags/#passing-data","title":"Passing Data","text":"<p>Dedicated data MAY be passed to/from subscribers. If so, it MUST be specified through a struct at path <code>&lt;hook name&gt;</code> (i.e. <code>&lt;hook name&gt;.&lt;data key name&gt;</code>) in the NBT storage location <code>&lt;pack ID&gt;:hook</code>.</p> <p>It is the responsibility of the developer to define how subscribers are allowed to interact with this data (e.g. whether it is read-only or not).</p>"},{"location":"rules/function_tags/#example-usage","title":"Example Usage","text":"<p>File for <code>#foo:hook/my_hook</code> in datapack <code>foo</code> (hook definition):</p> <pre><code>{\n    \"values\": []\n}\n</code></pre> <p>Function <code>foo:_/call_my_hook</code> in datapack <code>foo</code> (calling function):</p> <pre><code>// initial value of 'some_value' is 5.\ndata modify storage foo:hook my_hook set value {some_data:5}\n// call hook:\nfunction #foo:hook/my_hook\n</code></pre> <p>File for <code>#foo:hook/my_hook</code> in datapack <code>bar</code> (specifying subscriber):</p> <pre><code>{\n    \"values\": [\n        \"bar:_/my_subscriber\"\n    ]\n}\n</code></pre> <p>Function <code>bar:_/my_implementor</code> in datapack <code>bar</code> (subscriber function):</p> <pre><code>// subscriber recieves 'some_value' as 5.\n\n// multiply 'some_data' by 2:\nexecute store result storage foo:hook my_hook.some_data int 2 run data get storage foo:hook my_hook.some_data\n// 'some_value' now 10.\n\n// end of hook (or next subscriber in pipeline) would recieve 'some_value' as 10.\n</code></pre>"},{"location":"rules/function_tags/#abstract-functions","title":"Abstract Functions","text":""},{"location":"rules/function_tags/#concept","title":"Concept","text":"<p>An abstract function represents a function with defined inputs and outputs, but an implementation that MUST be provided by another pack. Abstract functions are analagous to a developer functions but with the responsibilities of the defining and external pack reversed.</p> <p>The following sequence is proper usage of an abstract function:</p> <ol> <li>Caller (defining pack) sets inputs.</li> <li>Caller calls abstract function tag (which calls it's subscriber/implementation).</li> <li>Implementation (subscriber) performs it's function body and sets outputs.</li> <li>Caller reads and interprets outputs.</li> </ol>"},{"location":"rules/function_tags/#definition_1","title":"Definition","text":"<p>An abstract function is a function tag within the <code>abstract</code> directory or any subdirectory therein (<code>#&lt;pack ID&gt;:abstract/&lt;path...&gt;/&lt;abstract function name&gt;</code>). </p> <p>Abstract functions are public by definition. Any datapack that writes to an abstract function tag (excluding where it's defined) MUST set <code>\"replace\": true</code>.</p> <p>Abstract functions MUST be defined empty and <code>\"replace\":false</code>.</p> <p>While packs can include (provide implementation subscriber(s) for) abstract functions from outside of their namespace, abstract functions MUST NOT be called by any namespace other than the one that they are defined in.</p> <p>If a pack define any abstract functions, it MUST declare at least one abstract interface (with the assumption that, for all abstract functions defined, providing a subscriber is part of the implementation requirements of some abstract interface).</p> <p>Abstract functions MUST be documented via mcdoc.</p>"},{"location":"rules/function_tags/#input-and-output","title":"Input and Output","text":"<p>Dedicated abstract function input(s) MUST be specified through a struct at path <code>&lt;abstract function name&gt;</code> (i.e. <code>&lt;abstract function name&gt;.&lt;input name&gt;</code>) in the NBT storage location <code>&lt;pack ID&gt;:abstract/in</code>.</p> <p>Likewise, dedicated abstract function outputs(s) MUST be specified through a struct at path <code>&lt;abstract function name&gt;</code> (i.e. <code>&lt;abstract function name&gt;.&lt;output name&gt;</code>) in the NBT storage location <code>&lt;pack ID&gt;:abstract/out</code>.</p> <p>Output struct MUST be null before it's abstract function is called.</p>"},{"location":"rules/function_tags/#example-usage_1","title":"Example Usage","text":"<p>File for <code>#foo:abstract/my_abstract</code> in datapack <code>foo</code> (abstract function definition):</p> <pre><code>{\n    \"values\": []\n}\n</code></pre> <p>Function <code>foo:_/call_my_abstract</code> in datapack <code>foo</code> (calling function):</p> <pre><code>// set inputs:\ndata modify storage foo:abstract/in my_abstract set value {a:3, b:5}\n// clear output:\ndata remove storage foo:abstract/out my_abstract\n// call abstract function:\nfunction #foo:abstract/my_abstract\n</code></pre> <p>File for <code>#foo:abstract/my_abstract</code> in datapack <code>bar</code> (specifying subscriber):</p> <pre><code>{\n    \"replace\": true,\n    \"values\": [\n        \"bar:_/my_implementor\"\n    ]\n}\n</code></pre> <p>Function <code>bar:_/my_implementor</code> in datapack <code>bar</code> (subscriber function):</p> <pre><code>// add 'a' and 'b':\nexecute store result score *a _bar run data get storage foo:abstract/in my_abstract.a\nexecute store result score *b _bar run data get storage foo:abstract/in my_abstract.b\nscoreboard players operation *a _bar += *b _bar\n// perhaps another implementation would do something different.\n\n// set output:\nexecute store result storage foo:abstract/out my_abstract.result int 1 run scoreboard players get *a _bar\n</code></pre>"},{"location":"rules/functions/","title":"Public Functions","text":""},{"location":"rules/functions/#definition","title":"Definition","text":"<p>Public functions are split into 2 categories, user functions and developer functions.</p> <p>Public functions in the <code>-</code> directory of the <code>function</code> registry (<code>data/&lt;pack ID&gt;/function/-/...</code>) are user functions while all others are developer functions.</p>"},{"location":"rules/functions/#user-functions","title":"User Functions","text":"<p>User functions SHOULD produce intended functionality when called directly in-game (via player and/or command block) and generally SHOULD NOT be called by other functions.</p>"},{"location":"rules/functions/#inputs-outputs","title":"Inputs &amp; Outputs","text":"<p>User function dedicated inputs MUST be provided via macro arguements.</p> <p>User functions do not have dedicated outputs; all outputs are, formally speaking, a side-effect. (If a user function must have output, a common pattern is to set data in <code>&lt;pack ID&gt;:data</code>.)</p>"},{"location":"rules/functions/#return-codes","title":"Return Codes","text":"<p>Meaningful information/output MAY be conveyed through a user function's return code.</p>"},{"location":"rules/functions/#developer-functions","title":"Developer Functions","text":"<p>Developer functions SHOULD produce intended functionality when called from functions and generally SHOULD NOT be called directly in-game.</p> <p>Developer functions MUST be documented via mcdoc.</p>"},{"location":"rules/functions/#inputs","title":"Inputs","text":"<p>Given a developer function, <code>&lt;pack ID&gt;:&lt;path...&gt;/&lt;function name&gt;</code>, dedicated function input(s) MUST be specified through a struct at path <code>&lt;function name&gt;</code> (i.e. <code>&lt;function name&gt;.&lt;input name&gt;</code>) in the NBT storage location <code>&lt;pack ID&gt;:in</code>.</p> <p>Data at path <code>&lt;function name&gt;</code> in <code>&lt;pack ID&gt;:in</code> MUST be null immediately after it's function scope ends. (i.e. <code>&lt;pack ID&gt;:in &lt;function name&gt;</code> must be cleared just before the function ends.)</p> <p>For functions calling developer functions, it MUST be garunteed that no external functions are called between the time input data is set and the developer function is called.</p>"},{"location":"rules/functions/#outputs","title":"Outputs","text":"<p>Given a developer function, <code>&lt;pack ID&gt;:&lt;path...&gt;/&lt;function name&gt;</code>, dedicated function output(s) MUST be specified through a struct at path <code>&lt;function name&gt;</code> (i.e. <code>&lt;function name&gt;.&lt;output name&gt;</code>) in the NBT storage location <code>&lt;pack ID&gt;:out</code>.</p>"},{"location":"rules/functions/#return-codes_1","title":"Return Codes","text":"<p>Non-zero positive valued return codes for developer functions SHOULD represent a form of success, while 0 or negative values SHOULD represent a form of failure.</p> <p>Developer functions MAY not have any meaningful return codes (e.g. a function cannot fail, a function is very simple, etc.), in which case they SHOULD return 1 in all cases.</p>"},{"location":"rules/functions/#example","title":"Example","text":"<p>The following is an example developer function, <code>foo:do_something</code>:</p> <pre><code>#&gt; foo:do_something\n\n# clear outputs\ndata remove storage foo:out do_something\n\n# call main implementation body\nfunction foo:_/impl/do_something/main\n\n# clear inputs\ndata remove storage foo:in do_something\n\nreturn 1\n</code></pre>"},{"location":"rules/mcdoc/","title":"Mcdoc","text":""},{"location":"rules/mcdoc/#definition","title":"Definition","text":"<p>TENTATIVE: Mcdoc is an unfinished project (and the SC author's fluency with it could be better).</p> <p>Mcdoc is a language used to define and document NBT structure/types.</p> <p>Datapacks MUST include a top-level <code>mcdoc</code> directory (<code>&lt;datapack&gt;/mcdoc/</code>) with contents that conform to the specifications mentioned below.</p> <p>All public mcdoc definitions SHOULD be properly documented via documentation comments.</p> <p>ISSUE CRITICAL: Currently, mcdoc paths to external packs (as well as any absolute path) rely on knowledge of datapack names; this is problematic conceptually due to it's impurity, and concretely because standard datapack names have multiple formats.</p>"},{"location":"rules/mcdoc/#defmcdoc","title":"<code>def.mcdoc</code>","text":"<p>For defining shared/global, named data types.</p> <p>If a data type is referenced multiple times, not tied to any specific context, or is intended to be referenced by other packs, it SHOULD be defined in <code>def.mcdoc</code>.</p> <p>Data types defined in <code>def.mcdoc</code> SHOULD be referenced by other mcdoc file(s).</p> <p><code>def.mcdoc</code> MUST NOT contain any <code>dispatch</code> or <code>inject</code> statements.</p> <p>A datapack MAY omit the file <code>def.mcdoc</code> entirely if it would otherwise be empty.</p>"},{"location":"rules/mcdoc/#datamcdoc","title":"<code>data.mcdoc</code>","text":"<p>For defining <code>&lt;pack ID&gt;:data</code> structure.</p> <p><code>data.mcdoc</code> MUST define a struct named <code>Data</code> and dispatch it to <code>minecraft:storage[&lt;pack ID&gt;:data]</code> (<code>Data</code> defines the structure of <code>&lt;pack ID&gt;:data</code>).</p> <p><code>data.mcdoc</code> SHOULD NOT define any other named data types and MUST NOT include any other <code>dispatch</code> or <code>inject</code> statements.</p>"},{"location":"rules/mcdoc/#configmcdoc","title":"<code>config.mcdoc</code>","text":"<p>For defining <code>&lt;pack ID&gt;:config</code> structure.</p> <p><code>config.mcdoc</code> MUST define a struct named <code>Config</code> and dispatch it to <code>minecraft:storage[&lt;pack ID&gt;:config]</code> (<code>Config</code> defines the structure of <code>&lt;pack ID&gt;:config</code>).</p> <p><code>data.mcdoc</code> SHOULD NOT define any other named data types and MUST NOT include any other <code>dispatch</code> or <code>inject</code> statements.</p>"},{"location":"rules/mcdoc/#funcmcdoc","title":"<code>func.mcdoc</code>","text":"<p>TENTATIVE: This may not need to exist once <code>inject</code> is implemented in mcdoc; dedicated function mcdoc files could just inject into the in/out structs.</p> <p>For defining <code>&lt;pack ID&gt;:in</code> and <code>&lt;pack ID&gt;:out</code> structure via the structs defined in function mcdoc files.</p> <p><code>func.mcdoc</code> MUST define structs named <code>In</code> and <code>Out</code> and dispatch them to <code>minecraft:storage[&lt;pack ID&gt;:in]</code> and <code>minecraft:storage[&lt;pack ID&gt;:out]</code> respectively.</p> <p>For every developer function, <code>&lt;pack ID&gt;:&lt;path...&gt;/&lt;function name&gt;</code>, a pack defines, <code>In</code>/<code>Out</code> MUST contain the key <code>&lt;function name&gt;</code> that's type is the respective function mcdoc file's definition of <code>In</code>/<code>Out</code> respectively--or a union of them if multiple functions share the same <code>&lt;function name&gt;</code>. (This is just an enforcement of the input/output specification.)</p> <p>The <code>In</code> and <code>Out</code> structs MUST NOT define any keys outside of the specification described above.</p> <p><code>func.mcdoc</code> MUST NOT define any other named data types or include any other <code>dispatch</code> or <code>inject</code> statements.</p> <p>A datapack MAY omit the file <code>func.mcdoc</code> entirely if it does not define any developer functions.</p> <p>Example</p> <p>Pack <code>foo</code> defines the developer functions:</p> <ul> <li><code>foo:bar</code></li> <li><code>foo:baz</code></li> <li><code>foo:qux/baz</code></li> </ul> <p>it's <code>func.mcdoc</code> is:</p> <pre><code>dispatch minecraft:storage[foo:in] to struct In {\n    bar: super::function::bar::In,\n    baz: (super::function::baz::In, super::function::qux::baz::In)\n}\ndispatch minecraft:storage[foo:out] to struct Out {\n    bar: super::function::bar::Out,\n    baz: (super::function::baz::Out, super::function::qux::baz::Out)\n}\n</code></pre>"},{"location":"rules/mcdoc/#abstractmcdoc","title":"<code>abstract.mcdoc</code>","text":"<p>TENTATIVE: This may not need to exist once <code>inject</code> is implemented in mcdoc; dedicated function mcdoc files could just inject into the in/out structs. </p> <p>For defining <code>&lt;pack ID&gt;:abstract/in</code> and <code>&lt;pack ID&gt;:abstract/out</code> structure via the structs defined in abstract function mcdoc files. (Very similar to <code>func.mcdoc</code>.)</p> <p><code>abstract.mcdoc</code> MUST define structs named <code>In</code> and <code>Out</code> and dispatch them to <code>minecraft:storage[&lt;pack ID&gt;:abstract/in]</code> and <code>minecraft:storage[&lt;pack ID&gt;:abstract/out]</code> respectively.</p> <p>For every abstract function, <code>#&lt;pack ID&gt;:&lt;path...&gt;/&lt;abstract function name&gt;</code>, a pack defines, <code>In</code>/<code>Out</code> MUST contain the key <code>&lt;abstract function name&gt;</code> that's type is the respective abstract function mcdoc file's definition of <code>In</code>/<code>Out</code> respectively--or a union of them if multiple functions share the same <code>&lt;abstract function name&gt;</code>. (This is just an enforcement of the input/output specification.)</p> <p>The <code>In</code> and <code>Out</code> structs MUST NOT define any keys outside of the specification described above.</p> <p><code>abstract.mcdoc</code> MUST NOT define any other named data types or include any other <code>dispatch</code> or <code>inject</code> statements.</p> <p>A datapack MAY omit the file <code>abstract.mcdoc</code> entirely if it does not define any abstract functions.</p> <p>Example</p> <p>Pack <code>foo</code> defines the abstract functions:</p> <ul> <li><code>foo:abstract/bar</code></li> <li><code>foo:abstract/baz</code></li> <li><code>foo:abstract/qux/baz</code></li> </ul> <p>it's <code>abstract.mcdoc</code> is:</p> <pre><code>dispatch minecraft:storage[foo:abstract/in] to struct In {\n    bar: super::abstract::bar::In,\n    baz: (super::abstract::baz::In, super::abstract::qux::baz::In)\n}\ndispatch minecraft:storage[foo:abstract/out] to struct Out {\n    bar: super::abstract::bar::Out,\n    baz: (super::abstract::baz::Out, super::abstract::qux::baz::Out)\n}\n</code></pre>"},{"location":"rules/mcdoc/#hookmcdoc","title":"<code>hook.mcdoc</code>","text":"<p>For defining <code>&lt;pack ID&gt;:hook</code> structure via the structs defined in hook mcdoc files.</p> <p><code>hook.mcdoc</code> MUST define a struct named <code>Hook</code> and dispatch it to <code>minecraft:storage[&lt;pack ID&gt;:hook]</code>.</p> <p>for every hook, <code>#&lt;pack ID&gt;:&lt;path...&gt;/&lt;hook name&gt;</code>, a pack defines, <code>Hook</code> MUST contain the key <code>&lt;hook name&gt;</code> that's type is the respective hook mcdoc file's definition of <code>Hook</code> respectively--or a union of them if multiple hooks share the same <code>&lt;hook name&gt;</code>. (This is just an enforcement of the data-passing specification.)</p> <p>The <code>Hook</code> struct MUST NOT define any keys outside of the specification described above.</p> <p><code>hook.mcdoc</code> MUST NOT define any other named data types or include any other <code>dispatch</code> or <code>inject</code> statements.</p> <p>A datapack MAY omit the file <code>hook.mcdoc</code> entirely if it does not define any hooks.</p> <p>Example</p> <p>Pack <code>foo</code> defines the hooks:</p> <ul> <li><code>#foo:hook/bar</code></li> <li><code>#foo:hook/baz</code></li> <li><code>#foo:hook/qux/baz</code></li> </ul> <p>it's <code>hook.mcdoc</code> is:</p> <pre><code>dispatch minecraft:storage[foo:hook] to struct Hook {\n    bar: super::function::bar::Hook,\n    baz: (super::function::baz::Hook, super::function::qux::baz::Hook)\n}\n</code></pre>"},{"location":"rules/mcdoc/#externmcdoc","title":"<code>extern.mcdoc</code>","text":"<p>For external/misc. <code>dispatch</code> and <code>inject</code> statements.</p> <p>All public <code>dispatch</code> and <code>inject</code> statements that are not otherwise described in this specification (e.g. dispatching <code>mcdoc:custom_data</code>) MUST be contained in <code>extern.mcdoc</code>.</p> <p><code>extern.mcdoc</code> SHOULD NOT define any named data types.</p> <p>A datapack MAY omit the file <code>extern.mcdoc</code> entirely if it would otherwise be empty.</p>"},{"location":"rules/mcdoc/#function","title":"<code>function/...</code>","text":"<p>For individual developer function documentation and input/output definitions.</p> <p>For every developer function, <code>&lt;pack ID&gt;:&lt;path...&gt;/&lt;function name&gt;</code>, a pack defines, there MUST exist a mcdoc file at <code>function/&lt;path...&gt;/&lt;function name&gt;.mcdoc</code> that:</p> <ul> <li>MUST define structs <code>In</code> and <code>Out</code> that define the structure of the function's input and output respectively. (Dispatched to <code>&lt;function name&gt;</code> in <code>&lt;pack ID&gt;:in</code> and <code>&lt;pack ID&gt;:out</code> respectively in <code>func.mcdoc</code>.)</li> <li>MUST define data type <code>Return</code>, declaring the possible return codes of the function. <code>Return</code> MUST either be an <code>enum(int)</code> or a <code>type</code> with value <code>int @ &lt;min&gt;..&lt;max&gt;</code>. If the function's return code is unbounded, the range specifier (<code>@ &lt;min&gt;..&lt;max&gt;</code>) MUST be omitted.</li> <li>MUST NOT contain any <code>dispatch</code> or <code>inject</code> statements.</li> <li>SHOULD NOT define any other named data types unless they are exclusively related to the represented function conceptually.</li> <li>SHOULD contain comment line(s) at the beginning of the file documenting/describing the function.</li> </ul> <p>In comments, function inputs SHOULD be referenced by their path within <code>In</code> surrounded by <code>&lt;</code> and <code>&gt;</code> (\"&lt;<code>&lt;input path&gt;</code>&gt;\"); function outputs SHOULD be referenced by their path within <code>Out</code> surrounded by <code>&gt;</code> and <code>&lt;</code> (\"&gt;<code>&lt;output path&gt;</code>&lt;\").</p> <p>Example</p> <p>A pack, <code>foo</code>, defines the developer function <code>foo:math/add_numbers</code>. Mcdoc file <code>function/math/add_numbers.mcdoc</code> contains:</p> <pre><code>// Adds 2 ints, &lt;a&gt; and &lt;b&gt;.\n\nstruct In {\n    /// First number to add.\n    a: int,\n    /// Second number to add.\n    b: int,\n}\n\nstruct Out {\n    /// The result of the addition of &lt;a&gt; and &lt;b&gt;.\n    result: int\n}\n\n/// The result of the addition of &lt;a&gt; and &lt;b&gt;; matches &gt;result&lt;.\ntype Return = int\n</code></pre> <p>Input/output key documentation for such a simple function is somewhat pedantic/verbose but is included for the sake of example.</p> <p>A datapack MAY omit the directory <code>function</code> entirely if it does not define any developer function.</p>"},{"location":"rules/mcdoc/#abstract","title":"<code>abstract/...</code>","text":"<p>For individual abstract function documentation and input/output definitions. (Very similar to <code>`function/...</code>.)</p> <p>For every abstract function, <code>#&lt;pack ID&gt;:abstract/&lt;path...&gt;/&lt;abstract function name&gt;</code>, a pack defines, there MUST exist a mcdoc file at <code>abstract/&lt;path...&gt;/&lt;abstract function name&gt;.mcdoc</code> that:</p> <ul> <li>MUST define structs <code>In</code> and <code>Out</code> that define the structure of the function's input and output respectively. (Dispatched to <code>&lt;abstract function name&gt;</code> in <code>&lt;pack ID&gt;:abstract/in</code> and <code>&lt;pack ID&gt;:abstract/out</code> respectively in <code>abstract.mcdoc</code>.)</li> <li>MUST define data type <code>Return</code>, declaring the possible return codes of the function. <code>Return</code> MUST either be an <code>enum(int)</code> or a <code>type</code> with value <code>int @ &lt;min&gt;..&lt;max&gt;</code>. If the function's return code is unbounded, the range specifier (<code>@ &lt;min&gt;..&lt;max&gt;</code>) MUST be omitted.</li> <li>MUST NOT contain any <code>dispatch</code> or <code>inject</code> statements.</li> <li>SHOULD NOT define any other named data types unless they are exclusively related to the represented function conceptually.</li> <li>SHOULD contain comment line(s) at the beginning of the file documenting/describing the intended function behavior.</li> </ul> <p>In comments, function inputs SHOULD be referenced by their path within <code>In</code> surrounded by <code>&lt;</code> and <code>&gt;</code> (\"&lt;<code>&lt;input path&gt;</code>&gt;\"); function outputs SHOULD be referenced by their path within <code>Out</code> surrounded by <code>&gt;</code> and <code>&lt;</code> (\"&gt;<code>&lt;output path&gt;</code>&lt;\").</p> <p>Example</p> <p>A pack, <code>foo</code>, defines the abstract function <code>#foo:abstract/do_something</code>. Mcdoc file <code>abstract/do_something.mcdoc</code> contains:</p> <pre><code>// Does something with &lt;a&gt; and &lt;b&gt;.\n\nstruct In {\n    a: int,\n    b: any,\n}\n\nstruct Out {\n    /// The result of doing something to &lt;a&gt; and &lt;b&gt;.\n    result: int\n}\n\nenum(int) Return = {\n    Success = 1,\n    Fail = 0,\n}\n</code></pre> <p>A datapack MAY omit the directory <code>abstract</code> entirely if it does not define any abstract functions.</p>"},{"location":"rules/mcdoc/#hook","title":"<code>hook/...</code>","text":"<p>For individual hook documentation and pass-data definitions.</p> <p>For every hook, <code>#&lt;pack ID&gt;:hook/&lt;path...&gt;/&lt;hook name&gt;</code>, a pack defines, there MUST exist a mcdoc file at <code>hook/&lt;path...&gt;/&lt;hook name&gt;.mcdoc</code> that:</p> <ul> <li>MUST define struct <code>Hook</code> that defines the structure of the hook's pass-data. (Dispatched to <code>&lt;hook name&gt;</code> in <code>&lt;pack ID&gt;:hook</code> in <code>hook.mcdoc</code>.)</li> <li>MUST NOT contain any <code>dispatch</code> or <code>inject</code> statements.</li> <li>SHOULD NOT define any other named data types unless they are exclusively related to the represented hook conceptually.</li> <li>SHOULD contain comment line(s) at the beginning of the file documenting/describing the hook--in particular, exactly when it is called (and from what entrypoint \"timing\", if applicable).</li> </ul> <p>In comments, hook pass-data SHOULD be referenced by it's path within <code>Hook</code> surrounded by <code>&lt;</code> and <code>&gt;</code> (\"&lt;<code>&lt;pass-data path&gt;</code>&gt;\").</p> <p>Example</p> <p>A pack, <code>foo</code>, defines the hook <code>#foo:hook/bar</code>. Mcdoc file <code>hook/bar.mcdoc</code> contains:</p> <pre><code>// Called when \"bar\" happens AS and AT the player that did \"bar\".\n// Entrypoint timing 'tick'.\n// (Meaning this hook is called within the scope of the function schedule-loop initiated by foo's entrypoint 'tick'.)\n\nstruct Hook {\n    some_data: int\n    other_data: string\n}\n</code></pre> <p>A datapack MAY omit the directory <code>hook</code> entirely if it does not define any hooks.</p>"},{"location":"rules/mcdoc/#_","title":"<code>_/...</code>","text":"<p>For all private mcdoc structure/definitions.</p> <p>From Private:</p> <p>All structure defined by mcdoc files in the <code>_</code> directory and all subdirectories (<code>&lt;datapack&gt;/mcdoc/_/**</code>) [is private].</p> <p>A datapack MAY define any mcdoc files within the <code>_</code> directory, or MAY omit it entirely.</p> <p>Mcdoc files within <code>_</code> MUST NOT <code>dispatch</code> or <code>inject</code> to public data locations.</p> <p>Mcdoc files outside of <code>_</code> MUST NOT reference any structure defined by mcdoc files inside of <code>_</code>.</p> <p>Generally, private mcdoc structure is used to dispatch <code>minecraft:storage[&lt;pack ID&gt;:_]</code>, though this is not required.</p>"},{"location":"rules/naming/","title":"Naming Specifications","text":""},{"location":"rules/naming/#scoreboard-objectives","title":"Scoreboard Objectives","text":"<p>Public scoreboard objective names MUST be in the form <code>&lt;pack ID&gt;.&lt;identifier&gt;</code>, where <code>identifier</code> is a public identifier.</p> <p>Private scoreboard objective names (with the exception of the private register) MUST be in the form <code>_&lt;pack ID&gt;.&lt;identifier&gt;</code> where <code>identifier</code> is a private identifier.</p>"},{"location":"rules/naming/#entity-tags","title":"Entity Tags","text":"<p>Public entity tag names (with the exception of <code>_</code> and <code>-</code>) MUST be in the form <code>&lt;pack ID&gt;.&lt;identifier&gt;</code>, where <code>identifier</code> is a public identifier.</p> <p>Private entity tag names MUST be in the form <code>_&lt;pack ID&gt;.&lt;identifier&gt;</code> where <code>identifier</code> is a private identifier.</p>"},{"location":"rules/naming/#nbt-struct-keys","title":"NBT Struct Keys","text":"<p>NBT struct keys for all public data SHOULD conform to the following:</p> <ul> <li>Contain only lowercase alphanumeric characters and <code>_</code>.</li> <li>Not start or end with <code>_</code>.</li> </ul> <p>It MAY be reasonable to ignore these guidelines if an NBT key is intended to be manipulated or interacted with via macro.</p> <p>NBT struct keys for private data have no naming restrictions.</p>"},{"location":"rules/naming/#identifiers","title":"Identifiers","text":"<p>Identifiers are a concept defined by this specification for reference only and are not related to any in-game object/concept.</p>"},{"location":"rules/naming/#public-identifiers","title":"Public Identifiers","text":"<p>Public identifiers MUST conform to the following:</p> <ul> <li>1-64 characters in length.</li> <li>Contain only lowercase alphanumeric characters, <code>-</code>, and <code>_</code>.</li> <li>Not start or end with <code>-</code> or <code>_</code>.</li> </ul> <p>While not strictly required, public identifiers SHOULD conform to the following:</p> <ul> <li>3-32 characters in length.</li> <li>Contain no instances of multiple <code>-</code> or <code>_</code> in sequence.</li> <li>Use <code>_</code> to convey a space and <code>-</code> to convey a seperator.</li> <li>Start with a letter.</li> </ul>"},{"location":"rules/naming/#private-identifiers","title":"Private Identifiers","text":"<p>Private identifiers SHOULD conform to the public identifier requirements.</p> <p>See Datapack Naming for specification on names of datapacks themselves.</p>"},{"location":"rules/nbt_namespacing/","title":"Custom Data Namespacing","text":""},{"location":"rules/nbt_namespacing/#custom-data-component","title":"Custom Data Component","text":"<p>Packs MUST NOT define any data in the <code>minecraft:custom_data</code> component outside of the path/struct <code>&lt;pack ID&gt;</code>. (I.e. all data defined in <code>minecraft:custom_data</code> must have it's path start with <code>&lt;pack ID&gt;.</code>.)</p> <p>As of Minecraft version 1.21.11, this applies to items, blocks, and entities. Entities have their <code>minecraft:custom_data</code> at path <code>data</code>, as opposed to <code>components.\"minecraft:custom_data\"</code>.</p> <p>From Private:</p> <p>Data at path <code>&lt;pack ID&gt;._</code> in the <code>minecraft:custom_data</code> component [is defined as private].</p>"},{"location":"rules/nbt_namespacing/#pack-defined-data-locations","title":"Pack-Defined Data Locations","text":"<p>In instances where a pack defines it's own public shared data location with the intention of other packs storing/defining arbitrary data (i.e. serves a similar function of the <code>minecraft:custom_data</code> component), the same rules for <code>minecraft:custom_data</code> mentioned above SHOULD be enforced/followed. This includes the indication of private; data at relative path <code>&lt;pack ID&gt;._</code> SHOULD be treated as private.</p>"},{"location":"rules/nbt_storage/","title":"NBT Storage Locations","text":""},{"location":"rules/nbt_storage/#valid-locations","title":"Valid Locations","text":"<p>Data MUST NOT be stored in any NBT storage locations except for the following:</p>"},{"location":"rules/nbt_storage/#pack-iddata","title":"<code>&lt;pack ID&gt;:data</code>","text":"<p>For general-purpose public data.</p> <p>Data within this storage location is public and SHOULD be persistent.</p>"},{"location":"rules/nbt_storage/#pack-id_-and-any-subpath","title":"<code>&lt;pack ID&gt;:_</code> (and any subpath)","text":"<p>For all private data. (By definition, this is the only storage location that can hold private data.)</p> <p>Additionally, private data MAY be stored in any subpath of <code>&lt;pack ID&gt;:_</code> (e.g. <code>&lt;pack ID&gt;:_/foo/bar</code>). </p>"},{"location":"rules/nbt_storage/#pack-idapi","title":"<code>&lt;pack ID&gt;:api</code>","text":"<p>For specific/specialized-use or otherwise contextual, public ephemeral data.</p> <p>Data within this storage location is public and SHOULD be ephemeral.</p> <p>Intended to allow for flexibility of unique interactions/APIs, such as providing data to an externally provided function called via macro.</p>"},{"location":"rules/nbt_storage/#pack-idhook","title":"<code>&lt;pack ID&gt;:hook</code>","text":"<p>For passing data through hooks (see Hooks).</p>"},{"location":"rules/nbt_storage/#pack-idin","title":"<code>&lt;pack ID&gt;:in</code>","text":"<p>For passing inputs to developer functions (see Developer Functions).</p>"},{"location":"rules/nbt_storage/#pack-idout","title":"<code>&lt;pack ID&gt;:out</code>","text":"<p>For passing outputs from developer functions (see Developer Functions).</p>"},{"location":"rules/nbt_storage/#pack-idabstractin","title":"<code>&lt;pack ID&gt;:abstract/in</code>","text":"<p>For passing inputs to abstract functions (see Abstract Functions).</p>"},{"location":"rules/nbt_storage/#pack-idabstractout","title":"<code>&lt;pack ID&gt;:abstract/out</code>","text":"<p>For passing outputs from abstract functions (see Abstract Functions).</p>"},{"location":"rules/nbt_storage/#pack-idconfig","title":"<code>&lt;pack ID&gt;:config</code>","text":"<p>For specifying pack configuration (see Pack Config).</p>"},{"location":"rules/owned/","title":"Owned Objects","text":""},{"location":"rules/owned/#definition","title":"Definition","text":"<p>Some in-world objects (items, entities) can be marked as owned. Owned objects SHOULD NOT be treated like default/regular Minecraft objects, but MAY still be accessed by any datapack.</p> <p>Generally, owned indicates a \"custom\" object.</p> <p>The following are definitions of owned objects:</p>"},{"location":"rules/owned/#items","title":"Items","text":"<p>Items with <code>-:true</code> in their <code>minecraft:custom_data</code> component.</p>"},{"location":"rules/owned/#entities","title":"Entities","text":"<p>Entities with the '<code>-</code>' entity tag, excluding players.</p>"},{"location":"rules/owned/#handling-owned-objects","title":"Handling Owned Objects","text":"<p>As stated in the definition, owned objects SHOULD NOT be treated as default/regular Minecraft objects, but SHOULD still be recognized as objects of their type.</p> <p>Examples:</p> <ul> <li>A datapack that converts <code>stone_pickaxe</code>s to <code>copper_pickaxe</code>s SHOULD NOT convert owned <code>stone_pickaxe</code>s.</li> <li>A datapack that adds item transport pipes SHOULD transport owned items the same as regular items.</li> <li>A datapack that increases the health of zombies SHOULD NOT increase the health of owned zombies.</li> <li>A datapack that adds a weapon that knocks back mobs SHOULD knock back owned mobs.</li> </ul> <p>It is important to note the difference between private and owned: private objects MUST NOT be interacted with at all (other than by the defining pack); owned objects MAY be interacted with, but should not be treated as standard objects.</p>"},{"location":"rules/primary_namespace/","title":"Primary Namespace","text":""},{"location":"rules/primary_namespace/#definition","title":"Definition","text":"<p>A datapack MUST have exactly one primary namespace (also known as it's pack ID).</p> <p>A datapack MUST NOT define new resources in namespaces other than it's primary namespace.</p> <p>A datapack MAY overwrite/include resources in other namespaces if the resource already exists, given all dependencies are fulfilled. Resources manipulated in this way have their namespace referred to as secondary namespaces of the datapack.</p> <p>For example, including the block tag <code>#minecraft:dampens_vibrations</code> in your datapack is allowed, and would make <code>minecraft</code> a secondary namespace. Adding a new block tag that does not already exist in the <code>minecraft</code> namespace, like <code>#minecraft:foo_bar</code>, is not allowed.</p>"},{"location":"rules/primary_namespace/#naming","title":"Naming","text":"<p>Primary namespace names MUST fulfill the following criteria:</p> <ul> <li>Valid namespace name.</li> <li>1-64 characters in length.</li> <li>Contain only lowercase alphanumeric characters and <code>-</code>.</li> <li>Not start or end with <code>-</code>.</li> <li>Not be <code>minecraft</code> or <code>slimecore</code>.</li> </ul>"},{"location":"rules/primary_namespace/#recommendations","title":"Recommendations","text":"<p>While not strictly required, a good primary namespace name SHOULD follow the guidelines:</p> <ul> <li>4-32 characters in length.</li> <li>Uses <code>-</code> only as a \"module\" separator (e.g. <code>foo-feature1</code> and <code>foo-feature2</code>).</li> <li>Avoids numbers.</li> <li>Is as long/specific as reasonably possible if pack is not a library (or is not expected to be accessed frequently).</li> <li>Is easy to type but still reasonably specific if pack is a library (or is expected to accessed frequently).</li> </ul>"},{"location":"rules/private/","title":"Private Content","text":""},{"location":"rules/private/#definition","title":"Definition","text":"<p>Private content is content that MUST NOT be accessed by packs other than the pack that defines it. (I.e. private content does not exist to any pack outside of it's defining pack.)</p> <p>Content that is not private is public, and may be accessed by any pack.</p> <p>The following are definitions of private content:</p>"},{"location":"rules/private/#resourcesfiles","title":"Resources/Files","text":"<p>Resources in the <code>_</code> subdirectory (or any subdirectory therein) of any datapack registry (<code>&lt;datapack&gt;/data/&lt;pack ID&gt;/&lt;resource directory&gt;/_/...</code>). This includes tags (<code>data/&lt;pack ID&gt;/tags/&lt;resource directory&gt;/_/...</code>).</p>"},{"location":"rules/private/#scoreboard-objectives","title":"Scoreboard Objectives","text":"<p>Scoreboard objectives that start with <code>_&lt;pack ID&gt;</code>.</p>"},{"location":"rules/private/#nbt-storage-data","title":"NBT Storage Data","text":"<p>Data in the <code>&lt;pack ID&gt;:_</code> storage location or any sub-path of it (<code>&lt;pack ID&gt;:_/**</code>).</p>"},{"location":"rules/private/#minecraftcustom_data-component-data","title":"<code>minecraft:custom_data</code> Component Data","text":"<p>Data at path <code>&lt;pack ID&gt;._</code> in the <code>minecraft:custom_data</code> component.</p> <p>As of Minecraft version 1.21.11, this applies to items, blocks, and entities. Entities have their <code>minecraft:custom_data</code> at path <code>data</code>, as opposed to <code>components.\"minecraft:custom_data\"</code>.</p>"},{"location":"rules/private/#entity-tags","title":"Entity Tags","text":"<p>Entity tags that start with <code>_&lt;pack ID&gt;</code>.</p>"},{"location":"rules/private/#items","title":"Items","text":"<p>Items with <code>_:true</code> in their <code>minecraft:custom_data</code> component.</p> <p>Pack that added the <code>_:true</code> data first is the defining pack.</p>"},{"location":"rules/private/#entities","title":"Entities","text":"<p>Entities with the <code>_</code> entity tag, excluding players.</p> <p>Pack that added the <code>_</code> tag first is the defining pack.</p>"},{"location":"rules/private/#mcdoc-structure","title":"Mcdoc Structure","text":"<p>All structure defined by mcdoc files in the <code>_</code> directory and all subdirectories (<code>&lt;datapack&gt;/mcdoc/_/**</code>).</p>"},{"location":"rules/scoreboards/","title":"Scoreboards","text":""},{"location":"rules/scoreboards/#objectives","title":"Objectives","text":""},{"location":"rules/scoreboards/#public-objectives","title":"Public Objectives","text":"<p>Public scoreboard objectives MUST NOT have any variable scoreholders, only real-entity scoreholders.</p> <p>See the public objective naming specification.</p>"},{"location":"rules/scoreboards/#private-objectives","title":"Private Objectives","text":"<p>Private scoreboard objectives (with the exception of the private register) SHOULD NOT have any variable scoreholders, only real-entity scoreholders.</p> <p>See the private objective naming specification.</p>"},{"location":"rules/scoreboards/#private-register","title":"Private Register","text":"<p>The private register is a special private scoreboard objective that's name matches a pack's pack ID prefixed by <code>_</code> (<code>_&lt;pack ID&gt;</code>).</p> <p>Private registers SHOULD hold all of a pack's variable scoreholders.</p> <p>Private registers MUST NOT have any real-entity scoreholders.</p>"},{"location":"rules/scoreboards/#score-variables","title":"Score Variables","text":"<p>Score variables (commonly referred to as \"fake-players\") are scoreholders that are not intended to represent an entity or be selectable by a selector.</p> <p>Score variables SHOULD only be defined in private registers and MUST NOT be defined in any public objectives.</p> <p>Score variable names MUST start with <code>*</code>, but otherwise have no other restrictions.</p> <p>TENTATIVE: <code>#</code> and <code>$</code> prefix are already common within the current datapack community. Current rationale for <code>*</code> is that it is easy to spot and does not already have a common primary meaning; <code>#</code> is used to start comment lines and <code>$</code> is used to prefix macro arguments.</p>"},{"location":"slimecore/","title":"SlimeCore","text":"<p>SlimeCore is a datapack (and canonical namespace) that provides implementation for the robust datapack loading system that SC defines. Datapacks MUST implicitly depend upon it.</p> <p>The pages in this section describe subjects that are directly related to SlimeCore and it's systems. </p>"},{"location":"slimecore/#download-and-install","title":"Download and Install","text":"<p>The latest version of SlimeCore can be found here, and is installed like a standard datapack. Once installed, no further setup is required.</p>"},{"location":"slimecore/data/","title":"SlimeCore Data","text":"<p>After a successful rebuild, SlimeCore stores the build data in <code>slimecore:data</code>, referred to as the \"current build\", seperated into 2 structs <code>build</code> and <code>world</code>.</p> <p>All data in <code>slimecore:data</code> MUST be treated as read-only. Direct manipulation of data within <code>slimecore:data</code> may result in unexpected behavior.</p>"},{"location":"slimecore/data/#build","title":"<code>build</code>","text":"<p>Data stored at NBT path <code>build</code> is \"pure\" build data; it is evaluated solely using the data that pack manifests.</p> <p>The following are keys within the <code>build</code> struct:</p>"},{"location":"slimecore/data/#packs","title":"<code>packs</code>","text":"<p>The array of all enabled packs' pack manifests, in order in which their load tags are called.</p>"},{"location":"slimecore/data/#orderload","title":"<code>order.load</code>","text":"<p>An array of indexed pack references indicating the order in which pack load tags are called.</p> <p>Each element is a struct with the following keys:</p> Key Description <code>pack_ref</code> Pack ID of the represented pack. <code>index</code> Index of this pack in load order."},{"location":"slimecore/data/#orderentrypoint","title":"<code>order.entrypoint</code>","text":"<p>An array of indexed entrypoint references indicating the order in which entrypoints are called.</p> <p>Each element is a struct with the following keys:</p> Key Description <code>pack_ref</code> Pack ID of the pack this entrypoint is from. <code>id</code> Entrypoint ID of the represented entrypoint. <code>index</code> Index of this entrypoint in load order."},{"location":"slimecore/data/#orderpreload_entrypoint","title":"<code>order.preload_entrypoint</code>","text":"<p>An array of indexed entrypoint references indicating the order in which preload_entrypoints are called.</p> <p>Each element is a struct with the following keys:</p> Key Description <code>pack_ref</code> Pack ID of the pack this preload entrypoint is from. <code>id</code> Preload entrypoint ID of the represented entrypoint. <code>index</code> Index of this entrypoint in load order."},{"location":"slimecore/data/#auxpack_map","title":"<code>aux.pack_map</code>","text":"<p>Auxilary value--is just a useful re-representation of data, does not contain any new information.</p> <p>Struct that contains a key for every pack in the current build, it's key name being a pack ID, and it's value being the corresponding pack's pack manifest (<code>{&lt;pack ID...&gt;:&lt;pack manifest&gt;}</code>).</p>"},{"location":"slimecore/data/#auximpl_map","title":"<code>aux.impl_map</code>","text":"<p>Auxilary value--is just a useful re-representation of data, does not contain any new information.</p> <p>Struct that contains a path, <code>&lt;pack ID&gt;.&lt;abstract interface ID&gt;</code>, for every declared abstract interface, with the corresponding value being the pack manifest of the pack that implements it (<code>{&lt;pack ID...&gt;:{&lt;abstract interface ID...&gt;:&lt;implementor's pack manifest&gt;}}</code>).</p>"},{"location":"slimecore/data/#world","title":"<code>world</code>","text":"<p>Data stored at NBT path <code>build</code> is world-specific data; it may differ between two worlds even if they have exactly the same installed packs.</p> <p>The following are keys within the <code>world</code> struct:</p>"},{"location":"slimecore/data/#disabled_packs","title":"<code>disabled_packs</code>","text":"<p>Array of partial pack information that indicates which packs are installed but disabled.</p> <p>Each element is a partial pack manifest, only containing the <code>pack_id</code>, <code>author_id</code>, and <code>version</code> keys.</p>"},{"location":"slimecore/data/#datapack_links","title":"<code>datapack_links</code>","text":"<p>Array that contains each installed pack's datapack path along with it's pack ID.</p> <p>Each element is a struct with the following keys:</p> Key Description <code>pack_ref</code> Pack ID of the represented pack. <code>path</code> Datapack path of the represented pack (e.g. <code>file/foo</code>)."},{"location":"slimecore/data/#auxdatapack_link_map","title":"<code>aux.datapack_link_map</code>","text":"<p>Auxilary value--is just a useful re-representation of data, does not contain any new information.</p> <p>Struct that contains a key for every installed pack, it's key name being it's pack ID and it's value being it's datapack path (<code>{&lt;pack ID...&gt;:&lt;datapack path&gt;}</code>).</p>"},{"location":"slimecore/data/#the-slimecore-manifest","title":"The SlimeCore Manifest","text":"<p>The NBT path <code>slimecore</code> in <code>slimecore:data</code> contains a mock/reference pack manifest for SlimeCore itself.</p>"},{"location":"slimecore/datapack_names/","title":"Datapack Naming","text":""},{"location":"slimecore/datapack_names/#standard-format","title":"Standard Format","text":"<p>All datapack names (name of folder in world's <code>datapack</code> directory) SHOULD conform to one of the following formats:</p>"},{"location":"slimecore/datapack_names/#authored-and-versioned","title":"Authored and Versioned","text":"<p><code>&lt;author ID&gt;.&lt;pack ID&gt;.&lt;major ver&gt;.&lt;minor ver&gt;.&lt;patch ver&gt;</code></p> <p>Example: <code>sixslime.foo.1.2.3</code></p>"},{"location":"slimecore/datapack_names/#authored-and-unversioned","title":"Authored and Unversioned","text":"<p><code>&lt;author ID&gt;.&lt;pack ID&gt;</code></p> <p>Example: <code>sixslime.foo</code></p>"},{"location":"slimecore/datapack_names/#unauthored-and-versioned","title":"Unauthored and Versioned","text":"<p><code>&lt;pack ID&gt;.&lt;major ver&gt;.&lt;minor ver&gt;.&lt;patch ver&gt;</code></p> <p>Example: <code>foo.1.2.3</code></p>"},{"location":"slimecore/datapack_names/#unauthored-and-unversioned","title":"Unauthored and Unversioned","text":"<p><code>&lt;pack ID&gt;</code></p> <p>Example: <code>foo</code></p> <p>Fully released datapacks SHOULD match the Authored and Versioned format; all other formats are intended for datapacks that are still in development stages.</p>"},{"location":"slimecore/datapack_names/#non-standard-names","title":"Non-Standard Names","text":"<p>For every datapack with a name that does not match standard format, NBT path <code>datapack_path_overrides.&lt;pack ID&gt;</code> in storage location <code>slimecore:config</code> MUST contain their datapack path as a string.</p> <p>For example, if a datapack has the name <code>Non Standard foo</code> and it's manifest declares the pack ID <code>foo</code>, then <code>datapack_path_overrides.foo</code> in <code>slimecore:config</code> would contain the string <code>file/Non Standard foo</code>.</p> <p>SlimeCore will fail to rebuild if non-standard datapack names are not specified this way. (This only applies to datapacks that follow the SC spec.)</p>"},{"location":"slimecore/manifest/","title":"Pack Manifests","text":""},{"location":"slimecore/manifest/#definition","title":"Definition","text":"<p>Packs MUST NOT add to the function tags <code>#minecraft:load</code> or <code>#minecraft:tick</code>. Instead, packs MUST include a manifest that declares information on how to load them.</p> <p>To include a manifest, a pack MUST call the function <code>slimecore:api/manifest</code> exactly once within the scope of the function tag <code>#slimecore:manifest</code>.</p> <p>The following is a minimal template for a manifest function:</p> <pre><code>#&gt; MANIFEST\n\ndata modify storage slimecore:in manifest.pack.pack_id set value \"PACK ID\"\ndata modify storage slimecore:in manifest.pack.author_id set value \"AUTHOR ID\"\ndata modify storage slimecore:in manifest.pack.version set value {major:-1, minor:0, patch:0}\n# download MUST be of this exact version.\ndata modify storage slimecore:in manifest.pack.url set value \"DOWNLOAD URL\"\ndata modify storage slimecore:in manifest.pack.dependencies set value []\ndata modify storage slimecore:in manifest.pack.entrypoints set value []\ndata modify storage slimecore:in manifest.pack.preload_entrypoints set value []\ndata modify storage slimecore:in manifest.pack.abstract_declarations set value []\ndata modify storage slimecore:in manifest.pack.abstract_implementations set value []\ndata modify storage slimecore:in manifest.pack.is_library set value false\n\ndata modify storage slimecore:in manifest.pack.display.name set value \"DISPLAY NAME\"\ndata modify storage slimecore:in manifest.pack.display.summary set value \"DISPLAY SUMMARY\"\ndata modify storage slimecore:in manifest.pack.display.author_name set value \"DISPLAY AUTHOR NAME\"\n\n# optional\ndata modify storage slimecore:in manifest.pack.display.links.author set value \"AUTHOR URL\"\ndata modify storage slimecore:in manifest.pack.display.links.info set value \"INFO URL\"\ndata modify storage slimecore:in manifest.pack.display.links.versions set value \"LATEST/ALL VERSIONS URL\"\n\nfunction slimecore:api/manifest\n</code></pre> <p>This function should be private and added to the function tag <code>#slimecore:manifest</code>.</p>"},{"location":"slimecore/manifest/#pack_id-and-author_id","title":"<code>pack_id</code> and <code>author_id</code>","text":"<p>Pack ID: Must exactly match the pack's primary namespace.</p> <p>Author ID: While technically arbitrary, SHOULD identify the pack's author and stay consistent between packs released by the same author. (See ID Naming Rules)</p> <p>Together, a pack's pack ID and author ID uniquely identify it. Two packs that share the same pack ID and author ID are recognized as the same pack. No two installed packs can share the same pack ID; this would indicate a namespacing conflict.</p>"},{"location":"slimecore/manifest/#version","title":"<code>version</code>","text":"<p>The version of this pack, adhering to semantic versioning. Represented by a 3-key struct with keys <code>major</code>, <code>minor</code>, and <code>patch</code> (representing the version <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>). All 3 keys MUST be positive integers, with the minimum version being <code>0.1.0</code>.</p>"},{"location":"slimecore/manifest/#url","title":"<code>url</code>","text":"<p>A direct download URL of this pack. Must download the exact version of this pack specified by <code>version</code>.</p> <p>See Download URLs.</p>"},{"location":"slimecore/manifest/#dependencies","title":"<code>dependencies</code>","text":"<p>List of this pack's dependency declarations.</p> <p>A dependency is another pack that has it's resources and/or definitions referenced or used by this pack in any way. A dependency is said to be required if this pack cannot function without it, and optional if not (e.g. is only required for additional functionality).</p> <p>Each element of this list declares a dependency, and MUST be a struct with the following keys:</p> Key Description <code>pack_id</code> The pack ID of the dependency. <code>author_id</code> The author ID of the dependency. <code>version</code> The version of this dependency that is required, according to semantic versioning. Includes keys <code>major</code> and <code>minor</code> (not <code>patch</code>). <code>download.url</code> The direct download URL of the dependency. Download MUST be an exact version download, and a downloaded pack version must fulfill the version requirement specified by <code>version</code>. <code>download.version</code> The exact version of the dependency that <code>download.url</code> downloads. <code>optional</code> Boolean, <code>true</code> if dependency is optional, <code>false</code> if it is required. <p>The following is a template for a dependency declaration:</p> <pre><code># in manifest function...\ndata modify storage slimecore:in manifest.pack.dependencies append value {pack_id:\"DEP PACK ID\", author_id:\"DEP AUTHOR ID\", version:{major:-1, minor:0}, download:{url:\"DEP DOWNLOAD URL\", version:{major:-1, minor:0, patch:0}}, optional:false}\n</code></pre>"},{"location":"slimecore/manifest/#entrypoints","title":"<code>entrypoints</code>","text":"<p>List of this pack's entrypoint declarations.</p> <p>An entrypoint is a function tag matching <code>#&lt;pack ID&gt;:entrypoint/&lt;entrypoint ID&gt;</code>. Entrypoints are called during loading, after all load tags are called, in the order that they appear in <code>entrypoints</code>, while also respecting all 'before'/'after' relationships. Packs can declare any number of entrypoints.</p> <p>Each element of this list declares an entrypoint, and MUST be a struct with the following keys:</p> Key Description <code>id</code> This entrypoint's ID. A matching function tag MUST be defined at <code>#&lt;pack ID&gt;/entrypoint/&lt;id&gt;</code>. (See ID Naming Rules) <code>before</code> List of entrypoints from other packs that this entrypoint must be before in call order. Key MAY be omitted if empty. <code>after</code> List of entrypoints from other packs that this entrypoint must be after in call order. Key MAY be omitted if empty. <p>Each element of <code>before</code> and <code>after</code> keys MUST be a struct with the following keys:</p> Key Description <code>pack_ref</code> Pack reference (Referenced pack ID). <code>id</code> Entrypoint ID of referenced entrypoint. <p>The following is a template for an entrypoint declaration:</p> <pre><code># in manifest function...\ndata modify storage slimecore:in manifest.pack.entrypoints append value {id:\"ENTRYPOINT ID\"}\ndata modify storage slimecore:in manifest.pack.entrypoints[-1].before append value {pack_ref:\"OTHER PACK ID\", id:\"OTHER ENTRYPOINT ID 1\"}\ndata modify storage slimecore:in manifest.pack.entrypoints[-1].after append value {pack_ref:\"OTHER PACK ID\", id:\"OTHER ENTRYPOINT ID 2\"}\n</code></pre> <p>Because packs cannot add to <code>#minecraft:tick</code>, it is standard to declare entrypoint(s) that start self-scheduling function loops. A common pattern is to declare a single entrypoint with ID <code>tick</code>.</p> <p>With that being said, while one entrypoint is usually sufficient for a pack to function on it's own, a pack SHOULD declare multiple entrypoints if it performs multiple, conceptually distinct processes in it's tick loop. Declaring multiple entrypoints allows other packs more control over where they can insert their entrypoints, increasing integratability.</p>"},{"location":"slimecore/manifest/#preload_entrypoints","title":"<code>preload_entrypoints</code>","text":"<p>List of this pack's preload entrypoint declarations.</p> <p>A preload entrypoint is a function tag matching <code>#&lt;pack ID&gt;:preload_entrypoint/&lt;entrypoint ID&gt;</code>. Preload entrypoints are functionally identical to regular entrypoints, except they are called before any load tags are called (including the declaring pack's).</p> <p>Because they are called before any packs are loaded, anything within a preload entrypoint's scope MUST assume that no other packs exist, and that their own pack has not been loaded.</p> <p>Preload entrypoint declarations follow the same format as entrypoint declarations, but their <code>id</code> key must match to a <code>#&lt;pack ID&gt;:preload_entrypoint/&lt;id&gt;</code> function tag and their <code>before</code>/<code>after</code> keys must only reference other preload entrypoints.</p> <p>Preload entrypoints are intended for technical/meta pack processing and generally SHOULD NOT be declared without very good reason.</p> <p>Preload entrypoints SHOULD NOT start any self-scheduling function loops.</p>"},{"location":"slimecore/manifest/#abstract_declarations","title":"<code>abstract_declarations</code>","text":"<p>List of this pack's abstract interface declarations.</p> <p>An abstract interface is a representation of a contract that must be fulfilled (implemented) by another installed pack. For every abstract interface a pack declares, there must exist exactly one other installed pack that implements it.</p> <p>Generally, abstract interfaces are used to represent abstract functions, however, abstract interfaces can be used to represent any developer-defined contract that must be fulfilled by exactly one other pack.</p> <p>It is the responsibility of the author to define and document the fulfillment requirements of each of their pack's declared abstract interfaces.</p> <p>Packs that define any abstract functions MUST declare at least one abstract interface.</p> <p>Each element of this list declares an abstract interface, and MUST be a string indicating it's ID. (See ID Naming Rules)</p> <p>The following is a template for an abstract interface declaration:</p> <pre><code># in manifest function...\ndata modify storage slimecore:in manifest.pack.abstract_interfaces append value \"ABSTRACT INTERFACE ID\"\n</code></pre>"},{"location":"slimecore/manifest/#abstract_implementations","title":"<code>abstract_implementations</code>","text":"<p>List of this pack's declared abstract interface implementations.</p> <p>If this pack implements any abstract interfaces from other packs, it MUST be indicated here. It is the responsibility of the developer to ensure that abstract interface implementation requirements are properly fulfilled.</p> <p>Each element of this list declares an abstract interface implementation, and MUST be a struct with the following keys:</p> Key Description <code>pack_ref</code> Pack reference (Referenced pack ID). <code>id</code> ID of implemented abstract interface. <p>The following is a template for an abstract interface implementation declaration:</p> <pre><code># in manifest function...\ndata modify storage slimecore:in manifest.pack.abstract_implementations append value {pack_ref:\"OTHER PACK ID\", id:\"ABSTRACT INTERFACE ID\"}\n</code></pre>"},{"location":"slimecore/manifest/#is_library","title":"<code>is_library</code>","text":"<p>Boolean indicating whether or not this pack is a library or not.</p> <p>A pack SHOULD be indicated as a library if it does not provide any meaningful functionality or features on it's own and is intended to be used as a dependency of other packs; \"Meaningful\" is to the descretion of the developer to decide.</p> <p>From a user's perspective, if a pack is a library, it SHOULD be uninstalled if there are no packs that declare it as a dependency.</p>"},{"location":"slimecore/manifest/#display","title":"<code>display</code>","text":"<p>Informal information that is useful to users but is not used in processing.</p> <p>MUST be a struct with the following keys:</p> Key Description <code>name</code> Display name of this pack. <code>author_name</code> Author's display name. <code>summary</code> Breif 1-2 sentence length summary of this pack. <code>links</code> Struct containing external URLs of the author's choosing (see below). <p><code>links</code> MUST be a struct with the following keys, any/all of which MAY be omitted:</p> Key Description <code>author</code> URL intended to represent the author in a datapack or Minecraft related context (e.g. github profile, modrinth profile, etc.). <code>versions</code> URL where the latest version or all versions of this pack can be found (e.g. github repository, modrinth page, etc.). <code>info</code> URL to find information about this pack (e.g. documentation, wiki page, etc.). <p>See External URLs.</p>"},{"location":"slimecore/manifest/#notes","title":"Notes","text":""},{"location":"slimecore/manifest/#download-urls","title":"Download URLs","text":"<p>TENTATIVE: Direct download links are somewhat a hassle to obtain, but create the most streamlined experience, especially if download service is not enforced.</p> <p>URLs MUST use the https protocol and be a direct download (i.e. no clicking required). While no standard download service is enforced, it is RECOMMENDED to use GitHub releases or Modrinth. Redirect services or shortened URLs SHOULD NOT be used.</p> <p>The downloaded file MUST be a compressed archive (.zip, .tar, .tar.gz, etc.) that contains the contents of the datapack itself and SHOULD be named according to standard datapack naming formats.</p>"},{"location":"slimecore/manifest/#external-urls","title":"External URLs","text":"<p>URLs MUST use the https protocol. Redirect services or shortened URLs SHOULD NOT be used. Users are expected to navigate external URLs with the same amount of caution as they would with any other URL on the internet.</p>"},{"location":"slimecore/manifest/#manifest-pack-references","title":"Manifest Pack References","text":"<p>The <code>pack_ref</code> key contains another pack's pack ID, indicating a reference to that pack in some way. Any pack referenced this way MUST be included in <code>dependencies</code>.</p>"},{"location":"slimecore/manifest/#id-naming","title":"ID Naming","text":"<p>ID names MUST conform to the following:</p> <ul> <li>1-64 characters in length.</li> <li>Contain only lowercase alphanumeric characters, <code>-</code>, and <code>_</code> (spaces not allowed).</li> <li>Not start or end with <code>-</code> or <code>_</code>.</li> </ul> <p>While not strictly required, ID names SHOULD conform to the following:</p> <ul> <li>3+ characters in length.</li> <li>Contain no instances of multiple <code>-</code> or <code>_</code> in sequence.</li> <li>Use <code>_</code> to convey a space and <code>-</code> to convey a seperator.</li> <li>Start with a letter.</li> </ul>"},{"location":"slimecore/rebuilding/","title":"Loading &amp; Rebuilding","text":"<p>SlimeCore completely overhauls the way datapacks are loaded.</p> <p>As stated in Pack Manifests:</p> <p>Packs MUST NOT add to the function tags <code>#minecraft:load</code> or <code>#minecraft:tick</code> Instead, packs MUST include a manifest that declares information on how to load them.</p> <p>The <code>/datapack enable</code> and <code>/datapack disable</code> commands SHOULD NOT be used under any circumstance. Safe pack disabling/enabling/uninstalling is provided through explicit rebuilding.</p>"},{"location":"slimecore/rebuilding/#loading","title":"Loading","text":"<p>Loading always occurs upon world reload (<code>/reload</code>), and refers to the following sequence:</p> <ol> <li>Call all preload entrypoints.</li> <li>Call all load tags.</li> <li>Call all entrypoints.</li> </ol> <p>Call order in each step is determined by the world's current build.</p>"},{"location":"slimecore/rebuilding/#rebuilding","title":"Rebuilding","text":"<p>Rebuilding is the process of re-evaluating the world's current build given the currently installed/enabled/disabled packs. More specifically, it refers to the following sequence:</p> <ol> <li>Gather all pack manifests of all installed packs (including disabled).</li> <li>Verify that all packs have a known datapack path.</li> <li>Evaluate a build with pack manifests of enabled packs:<ol> <li>Verify that pack manifests are individually valid.</li> <li>Verify that there are no duplicate packs IDs.</li> <li>Verify that no abstract interfaces are implemented more than once.</li> <li>Verify that all dependencies are fulfilled.</li> <li>Verify that all abstract interfaces are implemented.</li> <li>Verify that there are no dependency cycles.</li> <li>Verify that there exists possible entrypoint and preload entrypoint orderings that fulfills all restrictions.</li> <li>Create a valid call order of preload entrypoints, load tags, and entrypoints.</li> </ol> </li> <li>If any packs are being disabled/uninstalled, uninstall/disable packs in reverse load order.</li> <li>Set the world's current build to the evaluated build.</li> <li>Trigger a load.</li> </ol> <p>If any step in the rebuild process fails, the world's previous build remains applied.</p> <p>By default, rebuilding occurs upon world reload (<code>/reload</code>) iff any changes to installed pack manifests are detected (including additions/removals).</p> <p>Rebuilding can be explicitly triggered.</p>"},{"location":"slimecore/rebuilding/#explicitly-rebuilding","title":"Explicitly Rebuilding","text":"<p>Calling the developer function <code>slimecore:rebuild</code> triggers an explicit rebuild. Explicit rebuilds allows for safe and tracked disabling/enabling/uninstalling of packs. Information on <code>slimecore:rebuild</code>'s usage can be found in it's respective function mcdoc file within the SlimeCore datapack.</p>"},{"location":"slimecore/rebuilding/#debugging-and-development","title":"Debugging and Development","text":"<p>SlimeCore alone does not provide any logging or feedback when loading or rebuilding, but it does provide hooks for these purposes, which any datapack can implement debug/logging subscribers.</p> <p>A basic (unofficial) debugging/devtool datapack can be found here.</p>"},{"location":"slimecore/special_tags/","title":"Top-Level Function Tags","text":"<p>Packs MUST define the following top-level function tags. These tags are automatically called by SlimeCore when appropriate and MUST NOT be called via any other means.</p>"},{"location":"slimecore/special_tags/#load-tag","title":"Load Tag","text":"<p>A pack's load tag is <code>#&lt;pack ID&gt;:load</code>.</p> <p>This tag is called on load; it is functionally a replacement for <code>#minecraft:load</code>.</p> <p>Functions within the scope of a load tag SHOULD setup/initialize it's pack, but SHOULD NOT run the <code>/schedule</code> command or start any self-scheduling function loops (entrypoints should be used for this purpose).</p> <p>If a pack has any dependencies, the dependent pack's load tag is always called after all of their dependencies' load tags are called. </p>"},{"location":"slimecore/special_tags/#disable-tag","title":"Disable Tag","text":"<p>A pack's disable tag is <code>#&lt;pack ID&gt;:disable</code>.</p> <p>This tag is called during rebuilding just before it's pack is disabled, given that the pack was not already disabled before rebuilding.</p> <p>Functions within the scope of a disable tag SHOULD temporarily and cleanly remove as much of it's packs influence/content as possible with the assumption that it will be re-enabled in the future--such that the pack \"picks back up where it left off\" when re-enabled.</p> <p>A pack's disable tag is not called when it is uninstalled, only when it is explicitly disabled.</p>"},{"location":"slimecore/special_tags/#uninstall-tag","title":"Uninstall Tag","text":"<p>A pack's uninstall tag is <code>#&lt;pack ID&gt;:uninstall</code>.</p> <p>This tag is called during rebuilding just before it's pack is uninstalled.</p> <p>Functions within the scope of an uninstall tag SHOULD permanently and cleanly remove as much content defined by it's pack as possible--such that re-enabling/re-installation of the pack would be no different than installing it for the first time. Content removal includes but is not limited too: scoreboard objectives, NBT storage data (emphasis on <code>&lt;pack ID&gt;:data</code> and <code>&lt;pack ID&gt;:config</code>), entities, custom items, etc.</p>"}]}